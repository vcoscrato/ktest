#' kGOFTest
#'
#' Performs a hypothesis test for goodness-of-fit based on the estimated kernel densities.
#'
#' @param data Either a list of numeric vectors, a numeric vector (with classes parameter defined), or a stacked data frame (first column with numeric values and second column with classes).
#' @param rfunc A function to generate data (see examples).
#' @param dfunc A function to evaluate real density values (see examples).
#' @param classes Classes relative to data parameter, should be used only when data is a numeric vector.
#' @param perm Boolean indicating weather to obtain the p-value trough the permutation test or just return return the common area between densities.
#' @param B Number of permutations.
#' @param bw The bandwidth used to estimate the kernel densities.
#' @param npoints The number of points used to estimate the kernel densities.
#' @param threads Number of cores to be used for parallel computing.
#' @param param_names A vector of variable names (as character). This parameter can be ignored when threads = 1. When using more then 1 threads, it is needed to export the global parameters name on the rfunc and dfunc functions (see examples).
#'
#' @return A list containing:
#'
#' - commonArea: Common area between the kernel and the theoric density.
#'
#' - p.value: The p-value generated by the permutation test (if perm = TRUE).
#'
#' @export
#'
#' @examples
#'
#' #When using no extra parameters on rfunc and dfunc:
#'
#' data = rnorm(100)
#'
#' rfunc = function(n) {
#'   return(rnorm(n, 0, 1))
#' }
#'
#' dfunc = function(x) {
#'   return(dnorm(x, 0, 1))
#' }
#'
#' kGOFTest(data, rfunc, dfunc)
#'
#' #When using parameters on rfunc and dfunc:
#'
#' data = rnorm(100)
#'
#' param1 = 0
#'
#' param2 = 1
#'
#' var_names = c(param1, param2)
#'
#' rfunc = function(n) {
#'   return(rnorm(n, param1, param2))
#' }
#'
#' dfunc = function(x) {
#'   return(dnorm(x, param1, param2))
#' }
#'
#' kGOFTest(data, rfunc, dfunc, param_names = c('param1', 'param2'))

kGOFTest = function(data, rfunc, dfunc, perm = TRUE, B = 5000, bw = bw.nrd0(data[,1]), npoints = 512, threads = detectCores() - 1, param_names = NULL) {

  if(!is.numeric(data)) {

    stop('data must be a numeric vector of data.')

  }

  if(!is.function(rfunc)) {

    stop('rfunc must be a function to generate data.')

  }

  if(!is.function(dfunc)) {

    stop('dfunc must be a function to evaluate real density values.')

  }

  data = data.frame(data, factor(1))

  d = densitiesEval(data, bw, npoints)$densities[[1]]

  k = commonAreaReal(d, dfunc)

  if(!perm) {

    return(list(commonArea = k))

  }

  if(threads > 1) {

    if(threads > detectCores()) {

      warning("threads inserted greater than available, parameter threads set to 1.")

      threads = 1

    }

    cl = makeCluster(threads)

    registerDoParallel(cl)

    on.exit(stopCluster(cl))

    Ti = foreach(i = 1:B, .combine = c, .export = c("commonAreaReal", "densitiesEval", param_names), .packages = "MESS") %dopar% {

      data[,1] = rfunc(nrow(data))

      return(commonAreaReal(densitiesEval(data, bw, npoints)$densities[[1]], dfunc))

    }

  } else {

    Ti = vector("numeric", B)

    for(i in 1:B) {

      data[,1] = rfunc(nrow(data))

      Ti[i] = commonAreaReal(densitiesEval(data, bw, npoints)$densities[[1]], dfunc)

    }

  }

  p = (1/B)*sum(Ti < k)

  plot(d, main = 'Comparison of densities', xlab = paste('Common area =', round(k, 4)), ylab = "")

  plot(dfunc, d$x[1], d$x[npoints], add = TRUE, col = 2)

  legend('topright', c('Data', 'Null hypothesis'), col = 1:2, bty = 'n', lwd = 1)

  return(list(commonArea = k, p.value = p))
}
